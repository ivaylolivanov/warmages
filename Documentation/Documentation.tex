\documentclass[
  10pt,
  a4paper,
  oneside,
  headers,
  headinclude,
  footinclude,
  BCOR5mm,
]{article}
\usepackage{ragged2e}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{beramono}
\usepackage[utf8]{inputenc}
\usepackage{listings}

\graphicspath{ {./images/} }

\title{IT Projekt}
\date{06.05.2019}
\author{Ivaylo Lenkov Ivanov}

\begin{document}

\begin{titlepage}
  \maketitle
  \tableofcontents
  \pagebreak
  \listoffigures
\end{titlepage}

\justify
\section{Einführung}
Für ein Hauptziel hat dieses Projekt eine virtuelle Umgebung zu bilden und in dieser Umwelt die grundlegende Physik zu simulieren. Die virtuelle Welt ähnelt ein Computerspiel.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.25]{VirtualEnvironment}
  \caption{Die virtuelle Umgebung}
  \label{fig:Umgebung}
\end{figure}

\justify
Der Benutzer steuert eine virtuelle Figur.

\begin{figure}[h]
  \captionsetup{justification=raggedright,singlelinecheck=false}
  \includegraphics[scale=0.10]{MageCharacter}
  \caption{Avatar}
  \label{fig:Avatar}
\end{figure}

\justify
Der Avatar kann sich in dem Terrain bewegen und Eiszapfen in jeden Richtung feuern. Die Anfangsszene dem Spiel hat vier Spielobjekte --- drei Kasten und ein Stein.

\begin{figure}[h]
  \begin{subfigure}{0.5\textwidth}
    \includegraphics[width=0.3\linewidth, height=2cm]{Box}
    \caption{Kasten}
    \label{fig:Kasten}
  \end{subfigure}
  \begin{subfigure}{0.5\textwidth}
    \includegraphics[width=0.3\linewidth, height=2cm]{Stone}
    \caption{Stein}
    \label{fig:Stein}
  \end{subfigure}

  \caption{Spielobjekte}
  \label{fig:Spielobjekte}
\end{figure}

\justify
Mit den Kisten kann der Anwender interagieren. Das heißt, dass der Benutzer sie herumschubsen kann und auch auf sie Eiszapfen zu schießen. Das kann zu der Zerstörung diesen Kästen führen. Der Stein, der auch statisch Spielobjekt genannt wird, funktioniert wie eine Wand. Er ist unbeweglich und auch unverwüstlich.

In meisten virtuellen Produkten wird die Information durch irgendeiner Art von Animation präsentiert. Animation bedeutet sichtbare Bewegung. Das kann sehr wichtig sein, weil es ein Software viel mehr intuitiv macht. In den meisten Fällen die Systeme, die solche Lebhaftigkeit machen, sind Physik-Engines.

Implementieren die Physik in einem virtuellen Welt macht die Animationen, die Bewegungen und die Wechselwirkungen in diesem Welt immer flüssiger und realistischer und gibt immersives Erlebnis. Die Bilder sieht schöner und lebendiger aus. Diese Eigenschaften sind wichtig nicht nur in den Computerspielen, sonder auch in der virtual Reality, in der Software für visuelle Effekte und in den Anwendungen für Physik Simulation und für Animation.

Für dieses Projekt wird ein Spiel erstellt, wo die grundlegende physikalischer Gesetze gelten. In der virtuellen Welt gibt es eine Implementation von Beschleunigung, Kollisionserkennung, Kollisionsauflösung und elementare Teilchen.

Solche Umfeldern sind kompliziert und braucht viel Speicher. Man soll auch auf der Leistung der Software passen. Diese virtuelle Umgebung wird durch die Programmiersprache C++ erstellt. Auf diese Weise wird der Speicher sehr streng kontrolliert. Die Sprache erlaubt bessere Performance und macht die Anwendung auch portabel. Für den Computergrafik teil wird die Programmiere-Bibliothek ``SDL2'' benutzt. Die ``png'' Bilder werden mit der Hilfe von der Programmiere-Bibliothek ``SDL2-image'' geladen.

\newpage
\section{Überblick}
Wenn man das ganze Projekt betrachtet, kann man die Teile des Spiels bemerken --- Initialisierung, die Spiel-Schleife und Befreiung des Speichers.\\
Während der Initialisierung wird das Fenster, wo die virtuelle Welt dargestellt wird. Die Texturen werden geladen. Danach wird die initiale Szene des Spiels geschaffen.\\
Die nächste Phase ist die Spiel-Schleife. Das ist der Kern jedes Spiels --- ein endlose, aber überwachte Kreislauf. Hier werden die Dynamik und die Interaktivität der virtuellen Welt durchgeführt. Hier werden 4 Teile erkennt --- das Normieren von der Bildrate, ein Prüfung auf Ausfahrt, Aktualisieren der Spielszene und Vorbereiten den Objekten zum Rendern und
das Rendern der Änderungen. Damit die Bildfrequenz normieren können, wird die Zeit der Rahmen für ein Iteration der Spiel-Schleife gefunden. Wenn diese Uhrzeit ist kleiner als die festgelegte, dann wird die Bildrate nachdrücklich verzögert. Das ist wichtig, weil auf diese Weise die verschiedene Computer die gleich Bildfrequenz haben werden.\\
Der Kreis ist endlos, aber das bedeutet nicht, dass das Spiel kein Schluss hat. Drücken ein Taster wird als ein Event registriert. Auf diese Weise kommuniziert der Benutzer mit der virtuellen Umgebung. Solche Veranstaltungen werden gesammelt und werden bearbeitet. In diesem Projekt bricht die Schleife das Drücken auf den Knopf ``ESC''.\\
Die Update-Phase des Spiel-Loops wird zunächst sichergestellt, dass alle Objekte, die in der Szene zerstört oder nicht mehr benötigt werden, keinen Speicher mehr beanspruchen. Mit anderen Worten, hält die Liste der Objekte, die verfolgt werden, aktuell. Dies ist entscheidend für die Leistung des Spiels. Nachdem bestätigt wurde, welche Spielobjekte in der Spielszene aktiv sind, werden ihre Position und ihr Zustand aktualisiert.\\
Danach wird festgestellt, ob ein Spielobjekt mit einem anderen kollidiert. Auf der Grundlage ihrem Typ wird eine bestimmte Art von Kollisionsauflösung ausgegeben. Die Auflösungen sind unterschiedlich, daher müssen sie getrennt werden. Im Projekt wird bei der ersten Kollision geprüft, ob der Avatar des Spielers mit einem anderen starren Körper kollidiert ist. Wenn dieser Schritt bestanden ist, kommt der Test, dass das Projektil mit einem beliebigen Objekt in der Spielszene kollidiert. Zunächst wird festgestellt, ob ein anderer Avatar getroffen wurde, was im aktuellen Projektstatus überflüssig ist, da der Benutzer der einzige ist, der einen hat. Wenn dann ein Projektil ein Spielobjekt geschlagen hat, werden zwei Arten von Lösungen implementiert. Wenn das getroffene Spielobjekt statisch ist, wird das Projektil einfach zerstört. Wenn das Spielobjekt jedoch beweglich ist, wird der Impuls des Aufpralls an es weitergeleitet und es entsprechend bewegt. Es gibt eine andere Art von Kollision --- zwischen einem beweglichen Objekt, das entweder von einem Avatar oder einem Projektil gedrückt wird, und einem anderen beweglichen Objekt. In diesem Fall werden die Impulse des sich bewegenden Spielobjekts an das im Ruhezustand befindliche weitergegeben.\\
Das Spiel implementiert den Kamerastil ``Smooth Follow''. Mit anderen Worten, das ist eine Kamera, die dem Avatar des Spielers folgt. Die Kamera wird zuletzt während der Aktualisierungsphase der Spieleschleife eingestellt. Auf diese Weise wird eine auftretende Kollision behoben und die Kamera wäre nicht schlecht positioniert.\\
Die letzte Phase der Spielschleife gibt das Ergebnis der vorherigen Phase wieder. Die Reihenfolge der Anzeige der Objekte auf dem Bildschirm ist sequentiell. Es ist sehr wichtig, dass zuerst das Gelände und dann alles andere gezeichnet wird, da dies dazu führen kann, dass der Avatar des Spielers unter die Karte gezogen wird und die Kacheln des Bereichs über das Sprite des Charakters gezogen werden, sodass der Benutzer den Charakter nicht sieht. Die genaue Renderreihenfolge ist zuerst --- die Karte, da sich alles auf der Oberfläche der Umgebung befinden soll, dann der Avatar des Spielers --- es ist das nächste beständigste Objekt in der Szene. Danach werden die Projektile und das andere Spielobjekt wie Kisten und Steine angezeigt.
\paragraph{}
Die Organisation der Daten im Spiel werden durch einfache Implementierung des Design-Musters \textbf{Entity-Component-System} erledigt. Festhaltend an seiner Philosophie werden die Eigenschaften der Objekte im Spiel als \textit{\textbf{Components}} dargestellt, die einem \textit{\textbf{Entity}}, wenn sie daran angehängt ist, Funktionalität verleihen. Alle \textit{Entities}, die erstellt wurden und erstellt werden, werden vom \textit{\textbf{Manager (System)}} gesteuert (verwaltet).\\

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.3]{Scheme}
  \caption{Entity-Component-System Verhältnisse}
  \label{fig:ECS}
\end{figure}

Man kann sich \textbf{Comopnents} als Container vorstellen. Sie besitzen keine komplexe Logik. Jeder Typ einer \textit{Component} kann an ein \textit{Entity} angehängt werden, um eine Art Eigenschaft bereitzustellen. Zum Beispiel macht eine \textit{Collider-Komponente} eine \textit{Entity} zu einem starren Objekt.\\
Die \textbf{Entities} werden hauptsächlich verwendet, um einen eindeutige Bezeichner anzubieten. Auf diese Weise wird die Umgebung auf die Existenz einzelner, individueller \textit{Entities} aufmerksam. Eine \textbf{Entity} fungiert als Root-Objekt, das eine Reihe von \textit{Components} bündelt.\\
Der \textbf{Manager (System)} fungiert als System-Teil des implementierten Entwurfsmusters. Es besitzt keine \textit{Entity}, sondern greift auf sie zu, um den Dateizyklus ihrer \textit{Components} zu verwalten.

\section{Physik}
In diesem Projekt geht es um Physik und deren Simulation in einer virtuellen Umgebung. Die grundlegenden Gesetze, die implementiert werden, sind Beschleunigung, Kollisionserkennung, Kollisionsauflösung und Partikel. Die ``Transform Component'' wurde zwecks die Simulation dieser Gesetze erstellt.

\begin{lstlisting}[language=C++]
  class TransformComponent : public Component
  {
    private:
    Vector2D position;
    Vector2D velocity;

    int speed  = 3;
    int width  = 32;
    int height = 32;
    int scale  = 1;

    float step;
    float acceleration;
    float friction = 0.2;
        ...
        ...
        ...
  };
\end{lstlisting}

Diese \textit{Components} enthält die meisten erforderlichen Eigenschaften für ein Element, das in einem bestimmten Bereich definiert werden soll. Es werden auch die Attribute festgelegt, die für die Bewegung des Gegenstands in diesem Bereich erforderlich sind.
Die Bewegung erfolgt über die Begriffe Geschwindigkeit als skalare Größe, Beschleunigung, Reibung, Geschwindigkeit als Vektorgröße. \\
\textbf{Geschwindigkeit als eine skalare Größe} kann als das Tempo betrachtet werden, mit dem ein Objekt die Entfernung zurücklegt. Stellen Sie sich ein Objekt mit hoher Geschwindigkeit vor. Gemäß der obigen Definition würde dies bedeuten, dass das Objekt in kurzer Zeit eine relativ große Entfernung zurücklegen würde. \\
\textbf{Die Geschwindigkeit als eine Vektorgröße} Es bezieht sich auf die Rate, mit der ein Objekt seine Position ändert.\\
Der Hauptunterschied zwischen den beiden Begriffen ergibt sich aus der Tatsache, dass Geschwindigkeit als skalare Größe die Richtung nicht verfolgt, während Geschwindigkeit als Vektorgröße richtungsbewusst ist. \\
Man kann die \textbf{Beschleunigung} als Vektorgröße definieren, die die Geschwindigkeit darstellt, mit der ein Objekt sein Tempo ändert. Mit anderen Worten, ein Objekt beschleunigt sich, wenn es seine Schnelligkeit ändert.\\
Der Begriff Reibung ist definiert als jede Kraft, die einer Relativbewegung widersteht. \\
Die Beschleunigung wird als Eigenschaft der ``Transform Component'' eingeführt. Mit jedem Frame wird sein Wert um einen bestimmten Schritt erhöht.

\begin{lstlisting}[language=C++]
    this->acceleration += this->step;

    if( this->acceleration > 7 )
        this->acceleration = 7;

    if( this->acceleration < 0 )
    {
        this->acceleration = 0;
        velocity.zero();
    }
\end{lstlisting}

Das implementierte Prinzip verwendet die Obergrenze für die Beschleunigung, um sie realistischer aussehen zu lassen.\\
Das einzige bewegliche Objekt ist der Avatar des Spielers. Sein Schritt ist mit seiner Schaffung festgelegt.

\begin{lstlisting}[language=C++]
    player.addComponent< TransformComponent >( 2 );
    player.getComponent< TransformComponent >().setStep( 0.15 );
    player.addComponent< SpriteComponent >( "player", true );
    player.addComponent< KeyboardConstroller >( );
    player.addComponent< ColliderComponent >( "player" );
    player.addGroup( groupPlayer );
\end{lstlisting}

Die tatsächliche Bewegung der Hauptfigur wird vom Benutzer gesteuert. Unter Verwendung der Definition von Trägheit --- die Tendenz eines Objekts, Änderungen seiner Geschwindigkeit zu widerstehen, passiert, was tatsächlich passiert, wenn der Benutzer den Avatar in der virtuellen Welt bewegt, indem Wert an die Geschwindigkeit der virtuellen Darstellung des Benutzers übergeben wird.\\

\begin{lstlisting}[language=C++]
    case SDLK_w:
        transform->getVelocity().setY( -1 );
        sprite->play( "walkUp" );
	break;
    case SDLK_a:
	transform->getVelocity().setX( -1 );
	sprite->play( "walkSideway" );
	sprite->spriteFlip = SDL_FLIP_HORIZONTAL;
	break;
    case SDLK_d:
	transform->getVelocity().setX( 1 );
	sprite->play( "walkSideway" );
	break;
    case SDLK_s:
	transform->getVelocity().setY( 1 );
	sprite->play( "walkDown" );
	break;
\end{lstlisting}

Zur leichteren Durchführung sind die Reibungsverläufe konstant. In Kombination mit der eingestellten Geschwindigkeit als Vektorgröße werden die Geschwindigkeit als Skalargröße und der Wert der Beschleunigung für das aktuelle Bild zur aktuellen Koordinate des Avatars addiert. Auf diese Weise wird das Zeichen im nächsten Frame an einer anderen Stelle angezeigt.

\begin{lstlisting}[language=C++]
    position.setX(
        tempX
        + velocity.getX()
        * this->speed
        * this->friction
        * this->acceleration
    );
    position.setY(
        tempY
        + velocity.getY()
        * this->speed
        * this->friction
        * this->acceleration
    );
\end{lstlisting}

Die Bewegungsimplementierung funktioniert für alle Objekte gleich. Der Hauptunterschied besteht darin, dass die Geschwindigkeit des Avatars immer dann eingestellt wird, wenn der Benutzer entscheidet, während die anderen Spielobjekte aufgrund einer Kollision ihre Position ändern.

\end{document}
